The Executor
The executor will take the command table generated by the parser and for every 
SimpleCommand in the array it will create a new process. It will also if necessary create pipes 
to communicate the output of one process to the input of the next one. Additionally, it will 
redirect the standard input, standard output, and standard error if there are any redirections. 
The figure below shows a command line “A | B | C | D”. If there is a redirection such as “< 
infile” detected by the parser, the input of the first SimpleCommand A  is redirected from 
infile. If there is an output redirection such as “> outfile”, it redirects the output of the last 
SimpleCommand (D) to outfile. 

executor/Screen Shot 2023-02-27 at 5.15.37 PM.png

If there is a redirection to errfile such as “>& errfile”  the stderr of all SimpleCommand 
processes will be redirected to errfile




remember is better make a pointer to the head of the list and loop on it instead of loop on the list and change the position



/*
	***********************************************************
					
	***********************************************************
*/



void erase(node *head, int index)
{
    // Check if the linked list is empty
    if (head == NULL)
        return;

    // If the index is 0, then we want to remove the head of the list
    if (index == 0)
    {
        // Store a pointer to the head of the list
        node *temp = head;

        // Set the head of the list to point to the next node in the list
        head = head->next;

        // Free the memory allocated for the original head of the list
        free(temp);

        // Return from the function
        return;
    }

    // Store a pointer to the current node
    node *current = head;

    // Iterate through the linked list until we reach the node before the one we want to delete
    for (int i = 0; i < index - 1; i++)
    {
        // If the current node is NULL, then we have reached the end of the list
        if (current == NULL)
            return;

        // Move to the next node in the list
        current = current->next;
    }

    // Store a pointer to the node we want to delete
    node *temp = current->next;

    // If the node we want to delete is NULL, then we have reached the end of the list
    if (temp == NULL)
        return;

    // Set the next pointer of the current node to point to the node after the one we want to delete
    current->next = temp->next;

    // Free the memory allocated for the node we want to delete
    free(temp);
}


/*  who | awk '{print $1}' | sort | uniq -c | sort -n */
static char *cmd0[] = { "who",                0 };
static char *cmd1[] = { "awk",  "{print $1}", 0 };
static char *cmd2[] = { "sort",               0 };
static char *cmd3[] = { "uniq", "-c",         0 };
static char *cmd4[] = { "sort", "-n",         0 };

static char **cmds[] = { cmd0, cmd1, cmd2, cmd3, cmd4 };
static int   ncmds = sizeof(cmds) / sizeof(cmds[0]);



int main(int argc, char **argv)
{
    err_setarg0(argv[0]);
    if (argc == 1)
    {
        /* Run the built in pipe-line */
        exec_pipeline(ncmds, cmds); 
    }
    else
    {
        /* Run command line specified by user */
        exec_arguments(argc, argv);
    }
    corpse_collector();
    return(0);
}

// int main (int argc, char **argv, char ** envp)
// {
// 	t_hellmini seashell;
// 	char *pippo;

// 	seashell.env = ft_arrdup(envp);
// 	seashell.current_command = "ls";
// 	pippo = ft_append("usr/bin", &seashell);

// 	printf("path is : %s",pippo);


// 	// ft_getpath(&seashell);

// 	// exp_tkn("$USER",seashell.env);

// 	exit(0);
// }


			// pipe(fd);
			// close(fd[0]);
			// if (parser->cmd->next == NULL)
			// 	dup2(fd[1],STDOUT_FILENO);
			// 	ft_execv(parser->current_command,pid);

			// // fd_in fd_out
			// fd1 = dup(fd0);	//clone fd
			// close(fd0);
			// dup2(fd3,fd4);	//clone fd3 on fd4 
			// close(fd3);//dup2 duplicate the fd so is good to close the old one







/*
	***********************************************************
					ft_fixstinpipe
	***********************************************************
	dealt with the in and out of command and recall ft pipejunior 
	for eventually other pipe 
*/

void	ft_fixstinpipe(t_command *cmd, Pipe output)
{
	dup2(output[1], 1);
	close(output[0]);
	close(output[1]);
	if (cmd->next->spc[PIPE] == 0)
		return ;
	ft_pipejunior(cmd);
}

/*
	***********************************************************
					ft_pipejunior
	***********************************************************
	pipe fork chek
	maybe ft_execpipe must be bring here
*/

void	ft_pipejunior(t_command *cmd)
{
	pid_t	pid;
	Pipe	input;

	if (cmd->spc[PIPE])
	{
		if (pipe(input) != 0)
			perror("failed to create pipe");
		pid = fork();
		if ((pid < 0))
			perror("failed to fork");
		if (!pid)
			ft_fixstinpipe(cmd, input);
		dup2(input[0], 0);
		close(input[0]);
		close(input[1]);
	}
	// waitpid(0, &status ,0);	//? not sure if here or in ft_executor with a while loop or in ft pipe
	ft_execvepipe(cmd);
}

/*
	***********************************************************
					ft_pipe
	***********************************************************
	making start the magic trick 
	maybe ft_execpipe must be bring in an other function
	i've to study the  if else state to break the while 
*/

void	ft_pipe(t_command *cmd)
{
	pid_t	pid;
	int		status;

	while (cmd->spc[PIPE] 
		&& cmd->next->spc[PIPE])	// check it
	{
		pid = fork();
		if (pid < 0)
			perror("failed to fork");
		if (pid != 0)
			return ;	//  wait??
		ft_pipejunior(cmd);
		if (cmd->spc[PIPE])
			cmd = cmd->next;
		waitpid(0, &status, 0);		//? not sure if here or in ft_executor with a while loop
	}
}









void	ft_execvepipe(t_command *cmd,int fd)
{
	char	*path;
	char	**arg;

	arg = ft_listtomatrix(cmd);
	path = ft_findpath(cmd, 0);
		dup2(fd, 1);

	if (execve(path, arg, cmd->shell->env) == -1)
		perror("execution failed");
	
	int i =-1;
	while (arg[++i])
		ft_printf("arg[%d]:%s",i,arg[i]);


	ft_free_cmatrix(arg);
	free(path);
	// exit(EXIT_FAILURE);
}


void	ft_pipe(t_command *cmd)
{
	pid_t	pid;
	int		status;

	if ((pid = fork()) < 0)
			perror("filed to create fd");
	if (!pid)
		ft_pipeline(cmd);
	while ((waitpid(0, &status, 0)) != -1)
		;

}


void	ft_pipejunior(t_command *cmd, int *fd, int n_pipe)
{
	(void)n_pipe;
	(void)cmd;
    if (n_pipe > 0)
	    dup2(fd[0],0);
    else
        close(fd[0]);
	close(fd[0]);
	close(fd[1]);
	// if(n_pipe >=1)
		return ;
	// ft_pipeline(cmd);
}

void	ft_pipeline(t_command *cmd)
{
	int		fd[2];
	pid_t	pid;
	int		n_pipe;
    int     i = 0;
	// int		status;

	n_pipe = cmd->shell->mc_pipes;
	while (i < n_pipe)
	{
		if (pipe(fd) != 0)
			perror("filed to create fd");
		if ((pid = fork()) < 0)
			perror("failed to fork");
		if (!pid)
		{
			ft_pipejunior(cmd,fd,i);
		}
		// waitpid(0,&status,0);
		dup2(fd[1],1);
		close(fd[0]);
		close(fd[1]);
		i++;
			ft_execvepipe(cmd,fd[1]);
	}
}
